<?php
/**
 * @file
 * Provides primary Backdrop hook implementations.
 *
 * Developer module that assists a contributed module with version upgrade from
 * the Drupal 7.x to Backdrop 1.x core API. The module creates new code files by
 * modifying existing code files in accordance with the core API changes. The
 * initial Backdrop version would be a straight port of features from the Drupal
 * version.
 *
 * For a list of core API changes that are handled by this module, see:
 * - https://api.backdropcms.org/change-records
 *
 * Copyright 2008-11 by Jim Berry ("solotandem", http://drupal.org/user/240748)
 */

require_once('PhpParserAutoloader.php');
\PhpParser\PhpParserAutoloader::register();

use PhpParser\Error;
use PhpParser\NodeDumper;
use PhpParser\ParserFactory;
use PhpParser\Node;
use PhpParser\Node\Stmt\Function_;
use PhpParser\NodeTraverser;
use PhpParser\NodeVisitorAbstract;
use PhpParser\NodeFinder;
use PhpParser\Node\Stmt;
use PhpParser\PrettyPrinter;
use PhpParser\NodeVisitor\NameResolver;
use PhpParser\NodeVisitor\ParentConnectingVisitor;
use PhpParser\Node\Expr\Variable;
use PhpParser\Node\Expr\Array_;
use PhpParser\Node\Expr\ArrayItem;
use PhpParser\Node\Scalar\String_;
use PhpParser\Node\Stmt\Expression;
use PhpParser\Node\Stmt\Return_;
use PhpParser\Node\Expr\Assign;
use PhpParser\Node\Name;
use PhpParser\Node\Expr\FuncCall;
use PhpParser\BuilderFactory;
use PhpParser\BuilderHelpers;


/**
 * Defines an array used to insert blank lines into created code.
 */
define('CODER_UPGRADE_WHITESPACE', array('type' => T_WHITESPACE, 'value' => 1 ));

if (function_exists('t')) {
  // This code is being executed inside a process running Backdrop.
  module_load_include('inc', 'coder_upgrade', 'coder_upgrade');
}

/**
 * Implements hook_permission().
 */
function coder_upgrade_permission() {
  return array(
    'administer code conversions' => array(
      'title' => t('Administer code conversions'),
      'description' => t('Manage code conversion tasks for Coder Upgrade.'),
    ),
  );
}

/**
 * Implements hook_menu().
 */
function coder_upgrade_menu() {
  module_load_include('inc', 'coder_upgrade', 'includes/menu');
  return _coder_upgrade_menu();
}

/**
 * Implements hook_menu_alter().
 */
function coder_upgrade_menu_alter(&$items) {
  if (!module_exists('coder_review')) {
    // Remove the Coder menu item.
    unset($items['admin/config/development/coder']);
    // Promote the menu items defined by this module.
    $items['admin/config/development/coder-upgrade']['title'] = 'Coder Upgrade';
    $items['admin/config/development/coder-upgrade']['type'] = MENU_NORMAL_ITEM;
  }
}

/**
 * Implements hook_config_info().
 */
function coder_upgrade_config_info() {
  $prefixes['coder_upgrade.settings'] = array(
    'label' => t('Coder Upgrade settings'),
    'group' => t('Configuration'),
  );
  return $prefixes;
}

/**
 * Implements hook_autoload_info().
 */
function coder_upgrade_autoload_info() {
  return array(
    'PGPEditor' => 'grammar_parser/editor.inc',
    'PGPNode' => 'grammar_parser/list.inc',
    'PGPList' => 'grammar_parser/list.inc',
    'PGPBody' => 'grammar_parser/list.inc',
    'PGPExpression' => 'grammar_parser/list.inc',
    'PGPOperand' => 'grammar_parser/list.inc',
    'PGPString' => 'grammar_parser/list.inc',
    'PGPBase' => 'grammar_parser/object.inc',
    'PGPArray' => 'grammar_parser/object.inc',
    'PGPFunctionCall' => 'grammar_parser/object.inc',
    'PGPAssignment' => 'grammar_parser/object.inc',
    'PGPClass' => 'grammar_parser/object.inc',
    'PGPConditional' => 'grammar_parser/object.inc',
    'PGPFor' => 'grammar_parser/object.inc',
    'PGPForeach' => 'grammar_parser/object.inc',
    'PGPCase' => 'grammar_parser/object.inc',
    'PGPDeclare' => 'grammar_parser/object.inc',
    'PGPTryCatch' => 'grammar_parser/object.inc',
    'PGPListStatement' => 'grammar_parser/object.inc',
    'PGPNamespace' => 'grammar_parser/object.inc',
    'PGPUse' => 'grammar_parser/object.inc',
    'PGPParser' => 'grammar_parser/parser.inc',
    'PGPReader' => 'grammar_parser/reader.inc',
    'PGPWriter' => 'grammar_parser/writer.inc',
  );
}

/**
 * Implements hook_upgrade_upgrade_file_alter().
 */
function coder_upgrade_upgrade_file_alter(&$reader, &$asts) {
  global $_coder_upgrade_module_name, $_coder_upgrade_filename;
  // cdp("inside " . __FUNCTION__);
  // $nodes = &$reader->getFunctions();
  $config_function_exists = FALSE;

  $nodeFinder = new NodeFinder;
  
  $ast = &$asts;
  $nodes = $nodeFinder->findInstanceOf($ast, Node\Stmt\Function_::class);

  foreach ($nodes as &$node) {
    $item = &$node;
    $body = &$item->stmts;

    if (empty($body)) {
      continue;
    }
    else {
      $calls = $nodeFinder->find($body, function(Node $node) {
          return $node instanceof Node\expr\funcCall
          && $node->name == 'config_get';
      });
      // dpm($calls);

      // $calls = $body->searchAll('PGPFunctionCall', 'name', 'value', 'config_get')) {
       $build_config_function = FALSE;
      foreach ($calls as &$call) {
        if ($call->args[0]->value->value == $_coder_upgrade_module_name . ".settings") {
          $build_config_function = TRUE;
          break;
        }
      }
      if ($build_config_function && (strpos($_coder_upgrade_filename, '.module') !== FALSE)) {
        $function = $_coder_upgrade_module_name . "_config_info";
        if (!$config_function_exists) {
          coder_upgrade_build_config_function($node, $asts);
          $config_function_exists = TRUE;
        }
      }
      if (count($calls) > 1) {

        $config_var = new Variable('config');
        $config_call_name = new Name('config');
        $config_call_arg = new String_($_coder_upgrade_module_name . ".settings");
        $config_call = new FuncCall($config_call_name, array($config_call_arg));
        $assign = new Expression(new Assign($config_var, $config_call));
        array_unshift($body, $assign);


        foreach ($calls as &$call) {
          // if ($call->printParameter(0) == "'" .$_coder_upgrade_module_name . ".settings'") {
          if ($call->args[0]->value->value == $_coder_upgrade_module_name . '.settings') {
            // $call->name['value'] = '$config->get';
             $call->name = new Name('$config->get');
             $call->args = array($call->args[1]);
          }
        }
      }
    }
    // Todo same for config_set, config_clear.
  }
}

function coder_upgrade_build_config_function($node, &$asts) {
  global $_coder_upgrade_module_name, $_coder_upgrade_module_human_name;
 // $editor = PGPEditor::getInstance();

  // Create array items.
  $label_item_value = new FuncCall(new Name('t'), array(new String_($_coder_upgrade_module_human_name . " settings")));
  $group_item_value = new FuncCall(new Name('t'), array(new String_('Configuration')));

  $label_item = new ArrayItem($label_item_value, BuilderHelpers::normalizeValue('label'));
  $group_item = new ArrayItem($group_item_value, BuilderHelpers::normalizeValue('group'));

  // Create the prefixes variable
  $prefixes_array_name = new Variable('prefixes[\'' . $_coder_upgrade_module_name . '.settings\']');

  // Build the whole array.
  $prefixes_array = new Assign(BuilderHelpers::normalizeValue($prefixes_array_name), new Array_(array($label_item, $group_item)));

  // Add to the ast.
  $factory = new BuilderFactory();
  $builder = $factory->function($_coder_upgrade_module_name . '_config_info')
    ->addStmt($prefixes_array)
    ->addStmt(new Return_(new Variable('prefixes')))
    ->setDocComment("/**\n * Implements hook_config_info().\n */")
    ->getNode();
  $asts[] = $builder;

}
